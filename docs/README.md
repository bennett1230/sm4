 # SM4加密算法实现

## 概述
以下是SM4分组密码算法的纯Python实现，支持ECB模式的加密和解密功能。SM4是中国国家密码管理局发布的商用密码标准算法，采用128位密钥和128位分组长度。

## 🧠 核心组件详解

### 1. `S_BOX`：非线性字节替换表
固定的 256 字节 S-Box 表；用于 τ 非线性变换，提高算法的抗线性/差分攻击能力。

---

### 2. `FK` / `CK`：系统参数

- `FK`（4 个 32-bit 值）：用于初始化密钥扩展；
- `CK`（32 个 32-bit 值）：用于 32 轮轮密钥生成；
- 这两个参数是算法标准的一部分，用于增加密钥调度的非相关性。

---

### 3. `_rotl(x, n)`：循环左移操作

```python
((x << n) | (x >> (32 - n))) & 0xFFFFFFFF
```
实现 32 位整数的循环左移；在变换函数和密钥扩展中频繁使用。

---

### 4. `_tau(a)`：非线性变换 `τ`
将 32-bit 输入分成 4 个字节；每个字节通过 S-Box 替换后重新合并；增强非线性和字节级混淆性。

---

### 5. `_l(b)` 和 `_l_prime(b)`：线性变换 `L` 和 `L'`
L 用于加解密中的 T 变换；L' 用于密钥扩展中的 T' 变换；均通过多个移位和异或组合，提高扩散性。

---

### 6. `_t(x) / _t_prime(x)`：合成变换 `T` 和 `T'`
T(x) = L(τ(x))：用于加解密轮函数；T'(x) = L'(τ(x))：用于密钥扩展阶段。

---

### 7. `_expand_key(key)`：密钥扩展
输入主密钥（128 位），输出 32 个轮密钥；使用 T' 变换和系统参数 FK、CK；满足 SM4 加密每轮使用不同子密钥的设计。

---

### 8. `_f(x0, x1, x2, x3, rk)`：轮函数 `F`
```python
F = x0 ^ T(x1 ^ x2 ^ x3 ^ rk)
```
用于 SM4 的每一轮加解密操作；利用前四个状态变量和当前轮密钥。

#T-Table方法优化SM4加密算法
# SM4 算法 T-Table 优化实现说明

基于 SM4 对称加密算法，使用了 **T-Table 优化技术**，提升了加解密过程中的性能表现。以下是该优化方法的详细思路介绍。

---

## 核心思路

### 1. 什么是 T-Table 优化？

- T-Table（查表变换）是一种典型的对称密码算法性能优化方法。
- 它将算法中的非线性替换（S-Box）与线性变换结合预计算，生成多个查找表（T表）。
- 这样，在加解密的关键轮函数中，直接通过查表完成复杂的置换和变换，减少运行时计算量。
- 该方法广泛用于 AES 等算法的高效实现。

---

### 2. SM4 中的 T-Table 构造

- SM4 算法每轮关键的合成变换 T 为：
  
T(x) = L(τ(x)) = τ(x) ⊕ (τ(x) <<< 2) ⊕ (τ(x) <<< 10) ⊕ (τ(x) <<< 18) ⊕ (τ(x) <<< 24)


- 其中，\(\tau\) 是字节级 S-Box 替换，\(L\) 是线性变换。
- 优化思想：  
  将 S-Box 替换和对应的多次循环移位异或操作合并预计算成 4 个 256 项的查找表 `T[0..3][256]`，分别对应 32 位输入中 4 个字节位置。
- 每个表项为对应字节经过 S-Box 替换和线性变换后移位处理的结果。
- 加密轮函数中，对 32 位输入的每个字节，直接查表取值异或，完成 T 变换。

---

### 3. 优化实现细节

- **查表生成**  
  初始化时，针对 256 个可能的字节值，依次通过 S-Box 替换，然后根据字节位置构造出对应的 32 位结果，包含线性变换的异或和循环左移。

- **轮函数计算**  
  输入数据的 32 位值拆成 4 个字节，分别查 `T[0]`、`T[1]`、`T[2]`、`T[3]`，将结果异或得到最终输出。

- **密钥扩展**  
  轮密钥生成时也采用类似的 T’ 变换，提升效率。

- **计时功能**  
  代码中内置了加解密操作的精确计时，单位为毫秒，方便性能测试。

